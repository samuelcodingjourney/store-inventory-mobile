Assignment 7:
1. Stateless widget is when the state cannot be changed during the runtime of a Flutter application. So during the lifetime of the widget that has a stateless widget, the appearance and properties will not change. So in a way, these widgets are not dependent to other widgets. Stateful widget on the other hand is when some part of the interface will change during the program runtime. The widget can be drawn again multiple times. This is applicable when the part of the interface should change dynamically. 
2. On this mobile application, first widget that we use is called MyApp which is a stateless widget in main.dart. This widget is used to display the contents of the application using the home property. Inside this widget there are widgets of ThemeData and also MaterialApp. MaterialApp in this case is a widget it provides a wrapper around the material widgets so that the components and widgets provided by Flutter SDK. Widget BuildContext is called as an argument for build() method to build the widget of MyApp. ColorScheme widget here is used for colorscheme of the mobile applFication page. Colors widget is also used to get the color which is indigo in this case. MyHomePage stateless widget is also referenced here in the MyApp stateless widget attribute of home to display the contents of MyHomePage. In the menu.dart file we can see that there are widgets of ShopItem, MyHomePage that is stateless widget, Scaffold widget can be use to occupy the whole screen or the available space, AppBar widget contains the toolbar and other common action buttons usually its located at the top, Text to display text, SingleChildScrollView which is a widget which is a box where a widget can be scrolled, Padding which is a widget that adds padding or empty space around a widget or widgets, EdgeInsets which is a widget to control the area of a rectangle in four cardinal directions or for the four sides of the rectangle, Column is a widget taht arranges its chidl widgets in vertical way, TextAlign which is for aligning the text horizontally that is inside a parent widget's boundary, TextStyle can be used to customize the text widget, FontWeight to control the font weight of the text, GridView is a widget to display items in a two-dimensional way, ShopCard which is another stateless widget, Material widget to wraps widgets used for Material Design application, InkWell which can be used as a Button or a Gesture Detector, ScaffoldMessenger which is the widget used to store and manage SnackBar, SnackBar is a widget which will display at the bottom a brief message when a certain action had occured, Container which is mainly used for easier applying styling effects because those styling will be implemented to the child widgets of this container widget, Center which is a widget for centering the child to itself, MainAxisAlignment which is a widget to determine or manage the placement of the children along the main axis in a flex layout, and lastly Icon class or widget to show specific icons.  
3. To implement the steps for this assignment I needed to create a new flutter project and also initialize github so that I can connect from local directory to the GitHub directory. After setting up those, I needed to create a menu.dart file in the shopping_list/lib directory and importing material.dart in order to use what flutter can afford to. Also then I moved the class MyHomePage and class _MyHomePageState to the menu.dart file and then importing menu.dart inside main.dart. To create a simple widget in flutter, I needed to change the nature of the MyHomePage widget in the menu.dart from stateful to stateless. By adding the Widget build, creating the class to add text and cards by defining type by creating a new class of ShopItem then using it by creating a list of it and creating the objects of ShopItem which fills the text and icons needed for this assignment. Inside the Widget build method, there will be a code for displaying the view of the page which uses the widget Scaffold. This widget has attributes that differentiate parts of it for example the appBar and body attribute. I then needed to create a new stateless widget or class called ShopCard in order to display the cards. Finally, I performed git add, commit, and push. 
Assignment 8:
1. The difference between Navigator.push() and Navigator.pushReplacement() is that push method would just push a new page on top of the stack so for example we want to go to a create product screen, the screen will immediately be pushed on top of the stack so the current view of the application is going to be that create product screen. For pushReplacement() method if the current top of the stack is for example a screen of view product list screen and we want to go to create product screen, the top of the stack which is the view product screen will be popped and the create product screen will be pushed on top of the stack so that now the view will be on create product and the view product screen has been removed from the stack entirely unless the user decides to push to it again in the future.
2. Some of the common layout widgets are divided to two which are standard widgets like Container, GridView, ListView, and Stack also material widgets which are Card and ListTile. Container widget is used to seperate the widgets using padding, borders, or margins. Changing background color or image by placing entire layout into a Container is often best practice as well. GridView is used to lay widgets out as a two-dimensional list. If the contents inside is too big then it will automatically scrolls. ListView is a widget that is column wise so that when content is too long it will automatically provides scrolling. Stack is used to arrange widgets overlapped with base widget like image. Card widget has a single child that can be a column, row, list, grid or other widget with multiple children. ListTile is a widget to create row of 3 lines of text and icons. 
3. The form input elements in this assignment uses the form widgget and then a _Formkey as variable to be added to the key attribute. Input fields in the form widget uses several variables and a TextFormField widget wrapped in padding as one of the children in the column for each otf the fields. A button is needed to display the popup also. 
4. Clean architecture is used for seperation of concerns that the overall goal of this seperation concern with clean architecture uses dependency rule that features many layers like feature layer, domain layer, data layer and resources and shared library.
5. I Implemented the checklist by adding menu drawer for navigation, adding forms and input elements, and lastly display the data as poppup.
Assignment 9:
1. Yes without creating model we can retrieve JSON data and start to process or work on using that JSON data. However it is best or the best practice to create a model that would define the structure from that data beforehand for easier data processing from JSON data. At the end of the day, the options to choose which can be situational as well.
2. Function of CookieRequest can be used and shared with all components in a Flutter application because it stores the information about the user session and can be used during HTTP web request configure and HTTP Form Post activities.
3. Fetching data from JSON to Flutter has many examples such as fetching data from Django using JSON to Flutter. In order to do this, you need the http package and adding a code in the android/app/src/main/AndroidManifest.xml to allow Flutter app to acceess the internet. Example of retrieving JSON from an endpoint is by using the method Uri.parse and using asynchronous keyword in Flutter which is response await for http.get method. Then method like jsonDecode can decode the response to JSON na dthe JSON converted to Product object. 
4. For authentication between Django and Flutter, we must create the necessary methods in views.py and urls.py in Django to either receive request or send response. In flutter side, necessary api calls are needed and JSON processing in order to play with the data from Django database if necessary. To display the correct menus for example product list for logged in user, the json can already be filtered from the Django side or the back-end side before being send to the front-end side which in this case is the Flutter side.
5. On this assignment I used all of the widgets and their uses that I have already explained in the previous assignment. The only differences were actually the api calls and how to properly handle data from the internet.

6. Steps to implement above checklist.
Firstly I needed to create a new application in Django called authentication. This will be used for authentication in the flutter side. Login.dart file in Flutter was also necesarry to make in order to call the api to Django and compare if the username and password entered was valid for log in purposes. Same when implementing logout which the actual logout method was called in Django so Django receive the request to logout and then send the appropriate JsonResponse. A famous method to get the response object was fetch and additional url parsing methods like Uri.parse and asynchronous calls like await was needed to finally get the data. Lastly, a detail page for each product in the list product page was also created by just passing the context from one page to another and displaying all the attributes of that page. A button to go back to the products list page was also created on each detail page of the products. Lastly, a custom model creation in Flutter was used and the Product model is created. The model code was stored in product.dart in the lib/models folder and the code was generated quickly using the Quicktype website.